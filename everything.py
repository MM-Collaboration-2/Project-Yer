#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('utils.py', b'from re import findall, match\nfrom stack import Stack\n\n\n# \xd0\x9e\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5 \xd1\x80\xd0\xb5\xd0\xb3\xd1\x83\xd0\xbb\xd1\x8f\xd1\x80\xd0\xbd\xd1\x8b\xd1\x85 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb9 \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xbf\xd0\xb0\xd1\x82\xd1\x82\xd0\xb5\xd1\x80\xd0\xbd\xd0\xbe\xd0\xb2 \xd1\x82\xd0\xb8\xd0\xbf\xd0\xbe\xd0\xb2 \xd0\xb8 \xd0\xb8\xd0\xbc\xd0\xb5\xd0\xbd \xd1\x82\xd0\xb8\xd0\xbf\xd0\xbe\xd0\xb2\nglobal TOKEN_TYPES\nTOKEN_TYPES: dict[str, str] = {\n\n        # \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb4 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x8b\xd0\xbc\xd0\xb8\n        \'[a-zA-Z_][a-zA-Z0-9_]*\\ *\\(.*?\\)\': \'function\',\n        #\'[a-zA-Z_][a-zA-Z0-9_]*\\ *\\(\': \'function\',\n\n        # \xd0\xbe\xd1\x82\xd1\x80\xd0\xb8\xd1\x86\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb5 \xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xb0 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb4 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd1\x8f\xd0\xbc\xd0\xb8\n        \'-\\d+\\.\\d+\': \'float\',\n        \'-\\d+\': \'integer\',\n\n        # return \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb4 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x8b\xd0\xbc\xd0\xb8\n        \'[+\\-*/=<>!][=]?|return\': \'operation\',\n\n        # \xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb5 \xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xb0 \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd1\x8f\xd0\xbc\xd0\xb8\n        \'\\d+\\.\\d+\': \'float\',\n        \'\\d+\': \'integer\',\n\n        # \xd0\xb2\xd1\x81\xd0\xb5 \xd0\xb1\xd1\x83\xd0\xba\xd0\xb2\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xbe-\xd1\x86\xd0\xb8\xd1\x84\xd0\xb5\xd1\x80\xd0\xbd\xd1\x8b\xd0\xb5 \xd0\xba\xd0\xbe\xd0\xbc\xd0\xb1\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\n        \'[a-zA-Z_][a-zA-Z0-9_]*\': \'variable\',\n\n        # \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xba\xd0\xb8\n        \'\\(\': \'open_bracket\',\n        \'\\)\': \'close_bracket\',\n        \'\\[\': \'list\',\n        \'\\]\': \'square_close_bracket\',\n\n        # \xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb5 \xd1\x81\xd0\xb0\xd0\xbc\xd0\xb8 \xd0\xbf\xd0\xbe \xd1\x81\xd0\xb5\xd0\xb1\xd0\xb5\n        \'\\".*?\\"\': \'stringg\',\n\n        # \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5 \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd0\xba\n        \'\\[.*?\\]\': \'list\',\n        \'\\$argv\\d+\': \'argument\',\n        \',\': \'comma\',\n\n        }\n\n\n# \xd0\x9f\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd1\x82\xd0\xbe\xd0\xba\xd0\xb5\xd0\xbd\xd0\xbe\xd0\xb2 \xd0\xb8\xd0\xb7 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb8 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xb2 \xd0\xb8\xd0\xbd\xd1\x84\xd0\xb8\xd0\xba\xd1\x81\xd0\xbd\xd0\xbe\xd0\xbc \xd0\xb2\xd0\xb8\xd0\xb4\xd0\xb5\ndef tokens(infixexpr: str):\n    pattern = \'|\'.join(t for t in TOKEN_TYPES.keys())\n    return findall(pattern, infixexpr)\n\n\n# \xd0\x9e\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd1\x8f\xd0\xb5\xd0\xbc \xd1\x82\xd0\xb8\xd0\xbf \xd1\x82\xd0\xbe\xd0\xba\xd0\xb5\xd0\xbd\xd0\xb0\ndef token_type(token: str) -> str:\n    for pattern, token_type in TOKEN_TYPES.items():\n        if match(pattern, token):\n            return token_type\n    return \'other\'\n\n\ndef smart_split(expression: str):\n    parts = expression.split(\',\')\n    valid_parts = []\n    index: int = 0\n    while index < len(parts):\n        part = parts[index]\n\n        # \xd0\xbf\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb5\xd1\x80\xd0\xba\xd0\xb0 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb8\n        if part.strip().startswith(\'"\') and not part.strip().endswith(\'"\'):\n            while True:\n                index += 1\n                new_part = parts[index]\n                part +=  \',\' + new_part\n                if new_part.strip().endswith(\'"\'):\n                    break\n            \n        # \xd0\xbf\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb5\xd1\x80\xd0\xba\xd0\xb0 \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xba\xd0\xb0\n        if part.strip().startswith(\'[\'):\n            brackets: int = 0\n\n            # \xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xba\xd0\xb8 \xd0\xb2 \xd0\xbd\xd0\xb0\xd1\x87\xd0\xb0\xd0\xbb\xd0\xb5\n            for char in part.strip():\n                if char == \'[\':\n                    brackets += 1\n                else:\n                    break\n\n            # \xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xba\xd0\xb8 \xd0\xb2 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x86\xd0\xb5\n            for char in list(reversed(part.strip())):\n                if char == \']\':\n                    brackets -= 1\n                else:\n                    break\n\n            while brackets != 0:\n                index += 1\n                new_part = parts[index]\n                part += \',\' + new_part\n\n                # \xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xba\xd0\xb8 \xd0\xb2 \xd0\xbd\xd0\xb0\xd1\x87\xd0\xb0\xd0\xbb\xd0\xb5\n                for char in new_part.strip():\n                    if char == \'[\':\n                        brackets += 1\n                    else:\n                        break\n\n                # \xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xba\xd0\xb8 \xd0\xb2 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x86\xd0\xb5\n                for char in list(reversed(new_part.strip())):\n                    if char == \']\':\n                        brackets -= 1\n                    else:\n                        break\n\n\n        index += 1\n        valid_parts.append(part)\n    valid_parts = [p for p in valid_parts if p]\n\n    return valid_parts\n\n\ndef get_tokens(expression: str):\n    pattern = \'|\'.join(t for t in TOKEN_TYPES.keys())\n    args = findall(pattern, expression)\n    new_args = []\n    index: int = 0\n    while index < len(args):\n        token = args[index]\n\n        if token.startswith(\'-\') and len(token) > 1:\n            if len(new_args) > 0 and new_args[-1] not in [\'-\', \'+\']:\n                new_args.append(\'-\')\n                token = token[1:]\n\n\n        if token == \'[\':\n            brackets: int = 1\n            while brackets != 0:\n                index += 1\n                new_token = args[index]\n                token += new_token\n                if new_token == \'[\':\n                    brackets += 1\n                elif new_token == \']\':\n                    brackets -= 1\n\n        index += 1\n        new_args.append(token)\n\n    return new_args\n\n\n# \xd0\x9f\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5\xd1\x82 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd1\x83, \xd0\xb2\xd0\xbe\xd0\xb7\xd0\xb2\xd1\x80\xd0\xb0\xd1\x89\xd0\xb0\xd0\xb5\xd1\x82 \xd0\xbc\xd0\xb0\xd1\x81\xd1\x81\xd0\xb8\xd0\xb2 \xd1\x81 \xd1\x82\xd0\xbe\xd0\xba\xd0\xb5\xd0\xbd\xd0\xb0\xd0\xbc\xd0\xb8 \xd0\xb2 \xd0\xbf\xd0\xbe\xd1\x81\xd1\x82\xd1\x8b\xd0\xbd\xd1\x84\xd0\xb8\xd0\xba\xd1\x81\xd0\xbd\xd0\xbe\xd0\xb9 \xd1\x84\xd0\xbe\xd1\x80\xd0\xbc\xd0\xb5:\n# \'a = b + 2\' -> [\'a\', \'b\', \'2\', \'+\', \'=\']\ndef infix_to_postfix(infixexpr) -> list[str]:\n    prec = {}\n    prec["*"] = 3\n    prec["/"] = 3\n    prec["+"] = 2\n    prec["-"] = 2\n    prec["("] = 1\n    prec["="] = 1\n\n    op_stack = Stack()\n    postfix_list = []\n\n    token_list = get_tokens(infixexpr)\n\n    for token in token_list:\n        tok_type = token_type(token)\n        if tok_type == \'integer\':                   # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xbe\n            postfix_list.append(token)\n        elif tok_type == \'float\':                   # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xb4\xd1\x80\xd0\xbe\xd0\xb1\xd0\xbd\xd0\xbe\xd0\xb5\n            postfix_list.append(token)\n        elif tok_type == \'stringg\':                  # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\n            postfix_list.append(token)\n        elif tok_type == \'variable\':                # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xb0\xd1\x8f\n            postfix_list.append(token)\n        elif tok_type == \'list\':                    # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\n            postfix_list.append(token)\n        elif tok_type == \'function\':                # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd1\x8f\n            postfix_list.append(token)\n        elif tok_type == \'argument\':                # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\n            postfix_list.append(token)\n        elif tok_type == \'open_bracket\':\n            op_stack.push( token)\n        elif tok_type == \'close_bracket\':\n            top_token = op_stack.pop()\n            while top_token != \'(\':\n                postfix_list.append(top_token)\n                top_token = op_stack.pop()\n\n        else:\n            while (not op_stack.is_empty()) and \\\n                (prec.get(op_stack.peek(), 1) >= prec.get(token, 1)):\n                postfix_list.append(op_stack.pop())\n            op_stack.push(token)\n\n    while not op_stack.is_empty():\n        postfix_list.append(op_stack.pop())\n\n    return postfix_list\n\ndef syntax_analysis(text: str, logging:bool = False) -> str:\n    analysed_text = \'\'\n    brackets_open = (\'(\', \'{\', \'[\')\n    brackets_closed = (\')\', \'}\', \']\')\n    stack = Stack()\n    comment_flag = False\n    stringg_flag = False\n    for ch in text:\n        if ch == \'\\n\': # \xd1\x83\xd0\xb1\xd0\xb8\xd1\x80\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbd\xd0\xbe\xd1\x81 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb8\n            continue\n        if ch == \'\\\'\':\n            comment_flag = not(comment_flag)\n            continue\n        if comment_flag:\n            continue\n        if ch == \'"\':\n            stringg_flag = not(stringg_flag)\n            analysed_text += ch\n            continue\n        if stringg_flag:\n            analysed_text += ch\n            continue\n        else:\n            if ch != \' \': #\xd1\x82\xd0\xb0\xd0\xb1\xd1\x8b \xd1\x82\xd0\xbe\xd0\xb6\xd0\xb5 \xd1\x87\xd0\xb5\xd0\xba\xd0\xb0\xd1\x8e\xd1\x82\xd1\x81\xd1\x8f\n                analysed_text += ch\n            if ch in brackets_open:\n                stack.push(ch)\n            elif ch in brackets_closed:    \n                if stack.is_empty(): \n                    if logging: print("\xd0\x9e\xd1\x88\xd0\xb8\xd0\xb1\xd0\xba\xd0\xb0 \xd0\xb2 \xd1\x80\xd0\xb0\xd1\x81\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd\xd0\xbe\xd0\xb2\xd0\xba\xd0\xb5 \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xb5\xd0\xba (\xd0\xbd\xd0\xb5\xd1\x82 \xd0\xbd\xd0\xb8 \xd0\xbe\xd0\xb4\xd0\xbd\xd0\xbe\xd0\xb9 \xd0\xbe\xd1\x82\xd0\xba\xd1\x80\xd1\x8b\xd0\xb2\xd0\xb0\xd1\x8e\xd1\x89\xd0\xb5\xd0\xb9)")\n                    return \'\'\n                else:\n                    index = brackets_closed.index(ch)\n                    open_bracket = brackets_open[index]\n                    if stack.peek() == open_bracket:\n                        stack.pop()  \n                    else: \n                        if logging: print("\xd0\x9e\xd1\x88\xd0\xb8\xd0\xb1\xd0\xba\xd0\xb0 \xd0\xb2 \xd1\x80\xd0\xb0\xd1\x81\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd\xd0\xbe\xd0\xb2\xd0\xba\xd0\xb5 \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xb5\xd0\xba (\xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd0\xbd\xd1\x8f\xd1\x8f \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xba\xd0\xb0 \xd0\xbd\xd0\xb5 \xd1\x81\xd0\xbe\xd0\xb2\xd0\xbf\xd0\xb0\xd0\xb4\xd0\xb0\xd0\xb5\xd1\x82 \xd1\x81 \xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd1\x8b\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9, \xd1\x82\xd0\xb8\xd0\xbf\xd0\xbe \'{)\')")\n                        return \'\'\n\n    if not(stack.is_empty()):\n        if logging: print("\xd0\x9e\xd1\x88\xd0\xb8\xd0\xb1\xd0\xba\xd0\xb0 \xd0\xb2 \xd1\x80\xd0\xb0\xd1\x81\xd1\x81\xd1\x82\xd0\xb0\xd0\xbd\xd0\xbe\xd0\xb2\xd0\xba\xd0\xb5 \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xb5\xd0\xba (\xd0\xbd\xd0\xb5 \xd1\x85\xd0\xb2\xd0\xb0\xd1\x82\xd0\xb0\xd0\xb5\xd1\x82 \xd0\xb7\xd0\xb0\xd0\xba\xd1\x80\xd1\x8b\xd0\xb2\xd0\xb0\xd1\x8e\xd1\x89\xd0\xb5\xd0\xb9(\xd0\xb8\xd1\x85))")\n        return \'\'\n\n    return analysed_text\n    \n\nif __name__ == \'__main__\':\n    # text = \'3.0\'\n    # for t in get_tokens(text):\n    #     print(t, token_type(t))\n    text = \'list = [3, [1, 2], 4]\'\n    print(smart_split(text))\n')
    __stickytape_write_module('stack.py', b"class Stack():                          # \xd0\xa1\xd1\x82\xd0\xb5\xd0\xba \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xb4\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb2\xd0\xb0 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb9\n    def __init__(self):                 # \xd0\xba\xd0\xbe\xd1\x81\xd1\x82\xd1\x8b\xd0\xbb\xd1\x8c, \xd0\xbd\xd0\xb0\xd0\xb4\xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xb9\xd0\xba\xd0\xb0 \xd0\xbd\xd0\xb0\xd0\xb4 list'\xd0\xbe\xd0\xbc\n        self.list = []\n\n    def is_empty(self):\n        return len(self.list) == 0\n\n    def pop(self):\n        return self.list.pop()\n\n    def peek(self):\n        return self.list[-1]\n\n    def push(self, data):\n        self.list.append(data)\n\n    def clear(self):\n        self.list = []\n\n    def __repr__(self):\n        return str(self.list)\n")
    __stickytape_write_module('yer_builtins.py', b'from object import Object\nfrom integer import Integer\nfrom stringg import String\nfrom variable import Variable\nfrom callable import BuiltIn\nfrom storage import Storage\nfrom execute import execute\nfrom list import List\n\n\n\n\n\ndef get_object(param: Object) -> Object:\n\n    if param.type == \'variable\':\n        param: Object = param.obj\n    return param\n\n\n# functions to send to BuiltIn object\ndef yell_func(params: list[Object], storage: Storage):\n    stringg = \'\'.join(str(p) for p in params)\n    print(stringg)\n    return Integer(len(params))\n\n\ndef len_func(params: list[Object], storage: Storage):\n\n    if len(params) < 1:\n        return Integer(0)\n\n    param = get_object(params[0])\n\n    if param.type in [\'list\', \'stringg\']:\n        return Integer(param.len())\n    return Integer(0)\n\n\ndef get_func(params: list[Object], storage: Storage):\n    if len(params) < 2:\n        return Integer(0)\n\n    param1: Object = get_object(params[0])\n\n    param2: Object = get_object(params[1])\n\n    if param1.type not in [\'list\', \'stringg\'] or param2.type != \'integer\':\n        return Integer(0)\n    if 0 <= param2.data < len(param1.data):\n        return param1.get(param2.data)\n    return Integer(0)\n\n\ndef type_func(params: list[Object], storage: Storage):\n    if len(params) > 0:\n        param = get_object(params[0])\n        return String(param.type)\n    return Integer(0)\n    \n\ndef screw_on_func(params: list[Object], storage: Storage):\n    counter: int = 0\n    for param in params:\n        if param.type == \'stringg\':\n            if execute(param.data, storage):\n                counter += 1\n    return Integer(counter)\n    \n\ndef defined_func(params: list[Object], storage: Storage):\n    lst = []\n    for name, data in storage.variables.items():\n        sublst = []\n        sublst.append(String(name))\n        sublst.append(data)\n        lst.append(List(sublst))\n    return List(lst)\n\n\n\nBUILTINS: dict[str, Variable] = {\n\n    \'yell\': Variable(\'yell\', BuiltIn(yell_func)),\n    \'len\': Variable(\'len\', BuiltIn(len_func)),\n    \'get\': Variable(\'get\', BuiltIn(get_func)),\n    \'type\': Variable(\'type\', BuiltIn(type_func)),\n    \'screw_on\': Variable(\'screw_on\', BuiltIn(screw_on_func)),\n    \'defined\': Variable(\'defined\', BuiltIn(defined_func)),\n}\n\nif __name__ == \'__main__\':\n    from stack import Stack\n    stringg = String("test")\n    s = Storage(BUILTINS, Stack())\n    screw_on_func([stringg], s)\n    print(defined_func([], s))\n')
    __stickytape_write_module('object.py', b"class Object():\n    regex = '.*?'\n    type: str = 'object'\n    def __init__(self, data=0):\n        self.data: int = data\n                                        \n    def __repr__(self):\n        return str(self.data)\n")
    __stickytape_write_module('integer.py', b"from object import Object\n\n\nclass Integer(Object):\n    regex = '[-]?\\d+'\n    type: str = 'integer'\n    def __init__(self, number):\n        self.data = int(number)\n\n    def __repr__(self):\n        return str(self.data)\n")
    __stickytape_write_module('stringg.py', b'from object import Object\n\n\nclass String(Object):\n    regex = \'\\".*?\\"\'\n    type: str = \'stringg\'\n    def __init__(self, stringg):\n        self.data = str(stringg)\n        self.validate()\n\n    def validate(self):\n        if self.data.startswith(\'"\'):\n            self.data = self.data[1:]\n        if self.data.endswith(\'"\'):\n            self.data = self.data[:-1]\n\n    def len(self) -> int:\n        return len(self.data)\n\n\n    def get(self, index: int) -> Object:\n        return String(self.data[index])\n\n\n    def __repr__(self):\n        return str(self.data)\n')
    __stickytape_write_module('variable.py', b"from object import Object\n\n\nclass Variable(Object):                     # \xd0\xa5\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd1\x82 \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82\n    regex = '[a-zA-Z][a-zA-Z0-9_]*'\n    type: str = 'variable'\n    def __init__(self, name, obj: Object = Object()):   \n        self.name: str = name           \n        self.obj: Object = obj\n\n    def __repr__(self):\n        return str(self.obj)\n")
    __stickytape_write_module('callable.py', b'from object import Object\nfrom integer import Integer\nfrom block import Block\nfrom storage import Storage\n\n\nclass Function(Object):\n    regex: str = \'\'\n    type: str = \'function\'\n    specification: str = \'userdefined\'\n\n    def __init__(self, block: Block):\n        self.block = block\n\n    def run(self) -> Object:\n        obj: Object = self.block.run()\n        return obj\n        \n    def get_block(self) -> Block:\n        return self.block\n\n    def __repr__(self):\n        return \'fn#\'\n\nclass BuiltIn(Object):\n    regex: str = \'\'\n    type: str = \'function\'\n    specification: str = \'builtin\'\n\n    def __init__(self, function: callable):\n        self.function: callable = function\n\n    def run(self, arguments: list[Object], storage: Storage) -> Object:\n        obj: Object = self.function(arguments, storage)\n        return obj\n        \n    def __repr__(self):\n        return \'builtin#\'\n\n\n\n\nif __name__ == \'__main__\':\n    text = \'\'\'\nFunc(foo){\n    Expr{b="b"}\n    Expr{return b}\n}\nExpr{foo()}\n\'\'\'\n       \n')
    __stickytape_write_module('block.py', b"from object import Object\nfrom void import Void\nfrom integer import Integer\nfrom construction import Construction\n\n\nclass Block(Construction):\n    regex:str = 'Block'\n    name: str = 'Block'\n    def __init__(self, constructions: list[Construction]):\n        self.constructions: list[Construction] = constructions\n\n    def run(self):\n        result: Object = Void()\n        for construction in self.constructions:\n            result = construction.run()\n        return result\n\n    def __repr__(self):\n        block = '\\n'.join(str(c) for c in self.constructions)\n        block =  f'{self.name}' +'{' + f'\\n{block}\\n' + '}'\n        return block\n\n")
    __stickytape_write_module('void.py', b"from object import Object\n\n\nclass Void(Object):\n    regex: str = ''\n    type: str = 'void'\n\n    def __inif__(self, data: str=''):\n        self.data: str = str(data)\n    \n    def __repr__(self):\n        return 'void#' + str(self.data)\n")
    __stickytape_write_module('construction.py', b"class Construction():\n    regex: str = ''\n    name: str = 'Construction'\n    def __repr__(self):\n        return 'Construction'\n")
    __stickytape_write_module('storage.py', b'from stack import Stack\nfrom object import Object\nfrom integer import Integer\nfrom variable import Variable\nfrom construction import Construction\n\n\nclass Storage():                            # \xd0\xa5\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xbb\xd0\xb8\xd1\x89\xd0\xb5 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x8b\xd1\x85\n    def __init__(self, variables: dict, arguments_stack: Stack):         # \xd0\xb8 \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd0\xb9 \xd0\xb2 \xd0\xb1\xd1\x83\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xbc\n        self.variables: dict[str, Variable] = variables\n        ####\n        self.arguments_stack: Stack = arguments_stack\n        self.recursion_limit: int = 100\n\n    ####\n    def add_arguments(self, arguments: list[Object]):\n        self.arguments_stack.push(arguments)\n        if len(self.arguments_stack.list) >= self.recursion_limit:\n            raise BaseException("reached recursion limit")\n\n    ####\n    def get_arguments(self) -> Object:\n        if self.arguments_stack.is_empty():\n            return []\n        return self.arguments_stack.peek()\n\n    ####\n    def del_arguments(self):\n        if not self.arguments_stack.is_empty():\n            self.arguments_stack.pop()\n\n    def add(self, variable: Variable) -> None:\n        self.variables[variable.name] = variable\n\n    def set(self, name: str, obj: Object) -> None:\n        if self.declared(name):\n            self.get(name).obj = obj\n\n    def remove_variable(self, name: str) -> None:\n        if self.declared:\n            del self.variables[name]\n\n    def get(self, name: str) -> Variable:\n        var = self.variables.get(name, None)\n        return var\n\n    def declared(self, name: str) -> bool:\n        if self.get(name):\n            return True\n        return False\n\n    def type(self, name: str) -> str:\n        if self.declared(name):\n            return self.get(name).type\n        return \'\'\n\n')
    __stickytape_write_module('execute.py', b"from construction_tree import ConstructionTree\nfrom utils import syntax_analysis\nfrom storage import Storage\nfrom block import Block\n\n\n\n\ndef read_text(file: str):\n    try:\n        with open(file, 'r') as f:\n            text = f.read();\n            return text\n    except:\n        return ''\n\n\ndef execute(file: str, storage: Storage):\n    file += '.yer'\n    text = read_text(file)\n    if text:\n        text = syntax_analysis(text)\n        tree = ConstructionTree(text, storage)\n        block = tree.reduce()\n        block.run()\n        return True\n    return False\n")
    __stickytape_write_module('construction_tree.py', b'from re import search, compile\nfrom utils import syntax_analysis\nfrom stack import Stack\nfrom storage import Storage \nfrom construction import Construction\nfrom expression_block import ExpressionBlock\nfrom construction_types import CONSTRUCTIONS_TYPES\nfrom builder import Builder\n\n\nclass Node():\n    def __init__(self, data: str, subnodes=[]):\n        self.data: str = data\n        self.subnodes = subnodes\n        self.variables = {}\n\n    def __repr__(self):\n        return str(self.data) + \':\' + str(self.subnodes)\n\n\n\nclass ConstructionTree():\n\n    # \xd0\xa0\xd0\xb5\xd0\xb3\xd1\x83\xd0\xbb\xd1\x8f\xd1\x80\xd0\xba\xd0\xb0 \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xbd\xd0\xb0\xd1\x85\xd0\xbe\xd0\xb6\xd0\xb4\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb2\xd0\xbe\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8 \xd1\x87\xd1\x82\xd0\xbe \xd0\xbf\xd0\xbe\xd0\xbf\xd0\xb0\xd0\xb4\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f\n    pattern = compile(\'|\'.join(_ for _ in CONSTRUCTIONS_TYPES.keys()))\n\n    def __init__(self, text: str, storage: Storage):\n        self.text = text\n        self.root = self.parse(self.text, \'Main\')\n        self.storage: Storage = storage\n\n\n    def end_body(self, text) -> int:\n        index = 0\n        bracket_stack = Stack()\n        quotes_stack = Stack()\n\n        while index < len(text) - 1:                # \xd0\xbd\xd0\xb0\xd1\x85\xd0\xbe\xd0\xb4\xd0\xb8\xd0\xbc \xd0\xba\xd0\xbe\xd0\xbd\xd0\xb5\xd1\x86 \xd0\xb4\xd0\xb0\xd0\xbd\xd0\xbd\xd0\xbe\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n\n            if text[index] == \'\\"\':                 # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xba\xd0\xb0\xd0\xb2\xd1\x8b\xd1\x87\xd0\xba\xd0\xb0\n                if quotes_stack.is_empty():         # \xd0\xb8 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba \xd0\xbf\xd1\x83\xd1\x81\xd1\x82\xd0\xbe\xd0\xb9\n                    quotes_stack.push(text[index])  # \xd1\x82\xd1\x83\xd0\xb4\xd0\xb0\xd0\xb0\xd0\xb0\xd0\xb0\xd0\xb0 \xd0\xb5\xd1\x91\n                else:\n                    quotes_stack.pop()              # \xd0\xb8\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5 \xd0\xb5\xd1\x81\xd0\xb2\xd0\xbe\xd0\xb1\xd0\xbe\xd0\xb6\xd0\xb4\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd1\x82\xd0\xb5\xd0\xba\n\n            if quotes_stack.is_empty():             # \xd1\x82\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba \xd0\xba\xd0\xb0\xd0\xb2\xd1\x8b\xd1\x87\xd0\xb5\xd0\xba \xd0\xbf\xd1\x83\xd1\x81\xd1\x82\n                if text[index] == \'{\':              # \xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd0\xb1\xd0\xb0\xd1\x82\xd1\x8b\xd0\xb2\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xbd\xd0\xb0 \xd0\xbd\xd0\xb0\xd0\xbb\xd0\xb8\xd1\x87\xd0\xb8\xd0\xb5 \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd0\xba\n                    bracket_stack.push(\'{\')\n\n                elif text[index] == \'}\':\n                    bracket_stack.pop()\n\n                    if bracket_stack.is_empty():\n                        break\n            index += 1\n        \n        return index\n\n\n    def parse(self, text: str, header: str):\n        node = Node(header, [])                         # \xd0\xb7\xd0\xb0\xd0\xb3\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xba \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n        ###\n        #print(text)\n\n        while len(text) > 0:\n\n            m = search(self.pattern, text)\n\n            ###### \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5 \xd0\xbd\xd0\xb0\xd0\xb9\xd0\xb4\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xbe\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n            if m is None:\n                node.subnodes.append(Node(text, []))\n                return node\n            ######\n\n            new_header = text[m.start():m.end()]        # \xd0\xb7\xd0\xb0\xd0\xb3\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xba \xd0\xbd\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n            start_body = end_body = m.end()\n            stack = Stack()\n\n            end_body = self.end_body(text)             # \xd0\xbd\xd0\xb0\xd1\x85\xd0\xbe\xd0\xb4\xd0\xb8\xd0\xbc \xd0\xba\xd0\xbe\xd0\xbd\xd0\xb5\xd1\x86 \xd0\xb4\xd0\xb0\xd0\xbd\xd0\xbd\xd0\xbe\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n\n\n            ####### \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xb4\xd0\xbe \xd0\xbd\xd0\xb0\xd0\xb9\xd0\xb4\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xbe\xd0\xb9 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n            if len(text[:m.start()]) > 0:\n                node.subnodes.append(Node(text[:m.start()], []))\n            #######\n\n            # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xbd\xd0\xb0\xd0\xb9\xd0\xb4\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xb0\xd1\x8f \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd1\x8f -- \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\n            # \xd0\xb4\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd0\xbc \xd0\xbd\xd0\xbe\xd0\xb4\xd1\x83 \xd1\x81 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\xd0\xbc. \xd0\x92 \xd0\xb3\xd0\xbb\xd1\x83\xd0\xb1\xd0\xb8\xd0\xbd\xd1\x83 \xd0\xbd\xd0\xb5 \xd0\xbf\xd0\xb0\xd1\x80\xd1\x81\xd0\xb8\xd0\xbc\n            if new_header.startswith(\'Expr\'):\n                new_node = Node(text[m.start():end_body+1], [])\n\n            # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd1\x8f\n            elif new_header.startswith(\'Func\'):\n                new_node = self.parse(text[start_body+1:end_body], new_header)\n\n            # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xbb\xd1\x8e\xd0\xb1\xd0\xb0\xd1\x8f \xd0\xb4\xd1\x80\xd1\x83\xd0\xb3\xd0\xb0\xd1\x8f \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd1\x8f\n            # \xd0\xbf\xd0\xb0\xd1\x80\xd1\x81\xd0\xb8\xd0\xbc \xd0\xb5\xd0\xb5 \xd0\xb2 \xd0\xb3\xd0\xbb\xd1\x83\xd0\xb1\xd0\xb8\xd0\xbd\xd1\x83\n            else:\n                new_node = self.parse(text[start_body+1:end_body], new_header)\n\n            node.subnodes.append(new_node)\n\n            # \xd1\x83\xd0\xb4\xd0\xb0\xd0\xbb\xd1\x8f\xd0\xb5\xd0\xbc \xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd0\xb0\xd0\xbd\xd0\xbd\xd1\x83\xd1\x8e \xd1\x87\xd0\xb0\xd1\x81\xd1\x82\xd1\x8c \xd1\x82\xd0\xb5\xd0\xba\xd1\x81\xd1\x82\xd0\xb0\n            # \xd0\xb8\xd0\xb4\xd0\xb5\xd0\xbc \xd0\xb4\xd0\xb0\xd0\xbb\xd1\x8c\xd1\x88\xd0\xb5\n            text = text[end_body+1:]\n\n        return node\n\n    def run(self):\n        return self.reduce().run()\n\n\n    def reduce(self):\n        return self.__reduce(self.root, self.storage)\n\n    @classmethod\n    def __reduce(cls, node: Node, storage: Storage) -> Construction:\n        if node.data.startswith(\'Expr\'):\n            obj = ExpressionBlock(node.data, storage)\n            return obj\n        else:\n            lst = [cls.__reduce(n, storage) for n in node.subnodes]\n            obj: Construction = Builder.create_construction(node.data, lst, storage)\n            return obj\n\n    \n    def print(self):\n        self.__print(self.root)\n\n    @classmethod\n    def __print(cls, node: Node, t=0):\n        if node.data.startswith(\'Expr\'):\n            print(\'    \'*t, f\'{node.data}\')\n        else:\n            print(\'    \'*t, node.data, \'{\')\n            for n in node.subnodes:\n                cls.__print(n, t+1)\n            print(\'    \'*t, \'}\')\n\n\nif __name__ == \'__main__\':\n    text = \'\'\'\n    Func(myfunc){\n    a = $argv0;\n        While(a<1000){\n            a = a + 1;\n            yell(a);\n        }\n    }\n    c = 103;\n    myfunc(c);\n    \'\'\'\n    \n    text1 = \'\'\'\n    Func(fib){\n        a = 0;\n        b = 1;\n        c = 0;\n        For(i=0;i<$argv0;i=i+1){\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        c = 43;c=c+12;\n        return c;\n    }\n    r = fib(6);\n    yell(r);\n    \'\'\'\n    from yer_builtins import BUILTINS\n    text = syntax_analysis(text)\n    s = Storage(BUILTINS, Stack())\n    t = ConstructionTree(text, s)\n    b = t.reduce()\n\n    r = t.run()\n    print(r)\n    \n')
    __stickytape_write_module('expression_block.py', b'from construction import Construction\nfrom storage import Storage\nfrom expression import Expression\nfrom integer import Integer\nfrom void import Void\n\n\nclass ExpressionBlock(Construction):\n    regex: str = "Expr"\n    name: str = \'Expr\'\n    def __init__(self, stringg: str, storage: Storage, result_flag: bool=False):\n        self.storage: Storage = storage\n        self.stringg: str = stringg\n        self.result_flag = result_flag\n        self.expressions: list[Expression] = self.stringg_to_expressions()\n\n    def stringg_to_expressions(self):\n        stringg = self.clear()\n        expressions: list[str] = [s for s in stringg.split(\';\') if s]\n        expressions = [Expression(e, self.storage, self.result_flag) for e in expressions] \n        return expressions\n\n    def clear(self):\n        if self.stringg.startswith(\'Expr{\'):\n            return self.stringg[:-1].replace(\'Expr{\', \'\')\n        return self.stringg\n\n    def run(self):\n        result: Object = Void()\n        for expression in self.expressions:\n            result = expression.run()\n            if result.type != \'void\':\n                break\n        return result\n\n    def __repr__(self):\n        block = \'\\n\'.join(str(c) for c in self.expressions)\n        block =  f\'{self.name}\' +\'{\' + f\'\\n{block}\\n\' + \'}\'\n        return block\n\n')
    __stickytape_write_module('expression.py', b'from utils import tokens, token_type, infix_to_postfix, smart_split\nfrom stack import Stack\nfrom object import Object\nfrom void import Void\nfrom integer import Integer\nfrom list import List\nfrom variable import Variable\nfrom basic_types import BASIC_TYPES\nfrom storage import Storage\nfrom operation import Operation\nfrom construction import Construction\nfrom callable import Function, BuiltIn\n\n\nclass Expression(Construction):                                     # \xd0\x92\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5 \xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd0\xb8\xd1\x82 \xd0\xb8\xd0\xb7 \xd0\xbe\xd0\xb4\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe \xd0\xb8\xd0\xbb\xd0\xb8 \xd0\xbd\xd0\xb5\xd1\x81\xd0\xba\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xb8\xd1\x85 \xd0\xb1\xd0\xb0\xd0\xb7\xd0\xbe\xd0\xb2\xd1\x8b\xd1\x85 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb9\n    name: str = \'Exprssion\'\n    def __init__(self, stringg: str, storage: Storage, return_flag: bool=False):\n        self.storage: Storage = storage\n        self.stringg: str = stringg\n        self.postfix: list[str] = infix_to_postfix(self.clear())\n        self.return_flag: bool = return_flag\n        self.delete_flag: bool = False\n\n\n    def clear(self):\n        if self.stringg.startswith(\'Expr{\'):\n            return self.stringg[:-1].replace(\'Expr{\', \'\')\n        return self.stringg\n        \n    def run(self):                                                  # \xd1\x81\xd0\xbe\xd0\xb7\xd0\xb4\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xba\xd0\xbe\xd0\xbd\xd0\xb2\xd0\xb5\xd0\xb9\xd0\xb5\xd1\x80 \xd0\xb8\xd0\xb7 \xd1\x8d\xd0\xbb\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb0\xd1\x80\xd0\xbd\xd1\x8b\xd1\x85 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb9\n        #result: Object = Integer(0)\n        #######\n        result: Object = Void()\n        #######\n        stack: Stack = Stack()\n        for token in self.postfix:\n            tok_type = token_type(token)\n\n            if tok_type == \'operation\':                             # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xb0\xd1\x8f \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80 -- \xd1\x81\xd0\xbe\xd0\xb7\xd0\xb4\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xb1\xd0\xb0\xd0\xb7\xd0\xbe\xd0\xb2\xd1\x83\xd1\x8e \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd1\x8e\n\n                if token == \'return\':\n                    self.return_flag = True\n                    self.delete_flag = True\n                    continue\n\n                rop = stack.pop()\n                lop = stack.pop()\n                op = token\n                \n                result = Operation.run(lop, rop, op, self.storage)\n                # \xd0\x97\xd0\xb4\xd0\xb5\xd1\x81\xd1\x8c \xd0\xb2\xd0\xb0\xd0\xbb\xd0\xb8\xd0\xb4\xd0\xb8\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb0\xd1\x82\xd1\x8c \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb4\xd1\x8b\n                # \xd1\x82\xd0\xb0\xd0\xba \xd0\xba\xd0\xb0\xd0\xba \xd1\x80\xd0\xb5\xd0\xb7\xd1\x83\xd0\xbb\xd1\x8c\xd1\x82\xd0\xb0\xd1\x82 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8 \xd0\xb2\xd0\xbe\xd0\xb7\xd0\xb2\xd1\x80\xd0\xb0\xd1\x89\xd0\xb0\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f \xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd1\x82\xd0\xbd\xd0\xbe \xd0\xb2 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba\n                # \xd1\x82.\xd0\xb5. \xd1\x82\xd0\xb8\xd0\xbf \xd0\xb2\xd0\xbe\xd0\xb7\xd0\xb2\xd1\x80\xd0\xb0\xd1\x89\xd0\xb0\xd0\xb5\xd0\xbc\xd0\xbe\xd0\xb3\xd0\xbe \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb5\xd0\xb9 \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82\xd0\xb0\n                # \xd0\xb4\xd0\xbe\xd0\xbb\xd0\xb6\xd0\xb5\xd0\xbd \xd0\xb1\xd1\x8b\xd1\x82\xd1\x8c \xd1\x82\xd0\xb0\xd0\xba\xd0\xb8\xd0\xbc \xd0\xb6\xd0\xb5 \xd0\xba\xd0\xb0\xd0\xba \xd0\xb8 \xd1\x82\xd0\xb8\xd0\xbf \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82\xd0\xbe\xd0\xb2 \xd0\xb2 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba\xd0\xb5\n                # -- \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0 \xd0\xb8\xd0\xbb\xd0\xb8 Object.\n                # \xd0\x9a\xd0\xbe\xd0\xbd\xd0\xb2\xd0\xb5\xd1\x80\xd1\x82\xd0\xb8\xd1\x82\xd1\x8c \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd1\x83 \xd0\xb2 \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82 \xd0\xbf\xd0\xbe\xd1\x82\xd0\xbe\xd0\xbc \xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd1\x82\xd0\xbd\xd0\xbe \xd0\xb2 \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd1\x83 \n                # \xd1\x87\xd1\x82\xd0\xbe\xd0\xb1\xd1\x8b \xd0\xb7\xd0\xb0\xd1\x81\xd1\x83\xd0\xbd\xd1\x83\xd1\x82\xd1\x82\xd1\x8c \xd0\xb2 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba \xd0\xbd\xd0\xb5\xd0\xbe\xd1\x87 \xd0\xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd1\x87\xd0\xbd\xd0\xbe\n                # \xd0\xbb\xd1\x83\xd1\x87\xd1\x88\xd0\xb5 \xd1\x83\xd0\xb6 \xd0\xbd\xd0\xb0 \xd1\x85\xd0\xbe\xd0\xb4\xd1\x83 \xd0\xb7\xd0\xb4\xd0\xb5\xd1\x81\xd1\x8c \xd1\x82\xd0\xbe\xd0\xba\xd0\xb5\xd0\xbd\xd1\x8b \xd0\xb2 \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82\xd1\x8b \xd0\xb2\xd0\xb0\xd0\xbb\xd0\xb8\xd0\xb4\xd0\xb8\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb0\xd1\x82\xd1\x8c\n                #result = basic_expression.run()\n                stack.push(result)                                  # \xd0\xbf\xd0\xbe\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x80\xd0\xb5\xd0\xb7\xd1\x83\xd0\xbb\xd1\x8c\xd1\x82\xd0\xb0\xd1\x82 \xd0\xb2\xd1\x8b\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xb2 \xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd1\x82\xd0\xbd\xd0\xbe \xd0\xb2 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba\n            else:\n\n\n                obj = self.validate_operand(token, tok_type, self.storage)  # \xd1\x87\xd1\x82\xd0\xbe\xd0\xb1\xd1\x8b \xd0\xb2\xd0\xbe\xd0\xb7\xd0\xb2\xd1\x80\xd0\xb0\xd1\x89\xd0\xb0\xd1\x82\xd1\x8c \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd0\xbd\xd0\xb8\xd0\xb9 \xd0\xb4\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x8b\xd0\xb9 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb4\xd0\xb1 \xd0\xb2 \xd1\x81\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5 \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8\n                result = obj\n                stack.push(obj)                                     # \xd0\xbf\xd0\xbe\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xb2 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba\n\n        if self.return_flag:\n            # \xd1\x87\xd0\xb8\xd1\x81\xd0\xb8\xd0\xbc \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8b \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5 \xd0\xb2\xd1\x8b\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbd\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n            # \xd1\x83\xd0\xb4\xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5 \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xba\xd0\xb0 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xbe\xd0\xb2 \xd0\xb8\xd0\xb7 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba\xd0\xb0 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xbe\xd0\xb2 \xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xbb\xd0\xb8\xd1\x89\xd0\xb0\n\n            # \xd0\xb5\xd1\x81\xd0\xbb\xd0\xb8 \xd0\xbd\xd0\xb5 \xd0\xb1\xd1\x8b\xd0\xbb\xd0\xbe \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80\xd0\xb0 return, \xd0\xbd\xd0\xb5 \xd1\x83\xd0\xb4\xd0\xb0\xd0\xbb\xd1\x8f\xd0\xb5\xd0\xbc \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd1\x8b\n            if self.delete_flag:\n                self.storage.del_arguments()\n            # \xd0\xb2\xd0\xbe\xd0\xb7\xd0\xb2\xd1\x80\xd0\xb0\xd1\x89\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x80\xd0\xb5\xd0\xb7\xd1\x83\xd0\xbb\xd1\x8c\xd1\x82\xd0\xb0\xd1\x82\n            return result                                               # \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xb8\xd1\x81\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xb7\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xb2 \xd1\x83\xd1\x81\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xb8\xd1\x8f\xd1\x85 \xd0\xb8 \xd1\x86\xd0\xb8\xd0\xba\xd0\xbb\xd0\xb0\xd1\x85\n\n        # \xd0\xb2\xd0\xbe\xd0\xb7\xd0\xb2\xd1\x80\xd0\xb0\xd1\x89\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xbf\xd1\x83\xd1\x81\xd1\x82\xd0\xbe\xd1\x82\xd1\x83\n        return Void()\n\n\n    @classmethod\n    def validate_operation(cls, token: str):\n        # \xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd0\xba\xd0\xb0 return \xd0\xb8 += -= ...\n        pass\n\n\n    @classmethod\n    def validate_basic_object(cls, token: str, tok_type: str) -> Object:\n        obj = BASIC_TYPES[tok_type](token)\n        return obj\n\n\n    @classmethod\n    def validate_list(cls, token: str, storage: Storage) -> List:\n        # \xd0\xbe\xd1\x87\xd0\xb8\xd1\x81\xd1\x82\xd0\xba\xd0\xb0 \xd0\xbe\xd1\x82 \xd1\x81\xd0\xba\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x87\xd0\xb5\xd0\xba\n        token = token[1:-1]\n\n        lst: list[Object] = []\n\n        #exprs: list[Expression] = tokens(token)\n        #####!!!!!!FIXME \xd1\x80\xd0\xb0\xd0\xb7\xd0\xb1\xd0\xb8\xd0\xb2\xd0\xb0\xd0\xb5\xd1\x82 \xd0\xb2\xd0\xbd\xd1\x83\xd1\x82\xd1\x80\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xb8\xd0\xb5 \xd0\xbb\xd0\xb8\xd1\x81\xd1\x82\xd1\x8b \xd1\x82\xd0\xbe\xd0\xb6\xd0\xb5\n        #exprs: list[Expression] = token.split(\',\')\n        exprs: list[Expression] = smart_split(token)\n\n\n        ### \xd0\xb7\xd0\xb4\xd0\xb5\xd1\x81\xd1\x8c $argv \xd0\xb2 \xd1\x8d\xd0\xba\xd1\x81\xd0\xbf\xd1\x80\xd0\xb5\xd1\x88\xd0\xbd\xd0\xb5 \xd0\xbd\xd0\xb5 \xd0\xb2\xd0\xb0\xd0\xbb\xd0\xb8\xd0\xb4\xd0\xb8\xd1\x80\xd1\x83\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f\n        for expr in exprs:\n            expr = Expression(expr, storage, True)\n            obj = expr.run()\n            if obj.type == \'void\':\n                continue\n            lst.append(obj)\n        return List(lst)\n\n    @classmethod\n    def validate_variable(cls, token: str, storage: Storage):\n        if storage.declared(token):\n            variable: Variable = storage.get(token)\n\n        else:\n            variable: Variable = Variable(token, Integer(0)) # \xd1\x81\xd0\xbe\xd0\xb7\xd0\xb4\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xbd\xd0\xbe\xd0\xb2\xd1\x83\xd1\x8e\n            storage.add(variable);\n        \n        return variable\n\n    @classmethod\n    def validate_argument(cls, token: str, storage: Storage):\n\n        # \xd0\xbf\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xbd\xd0\xbe\xd0\xbc\xd0\xb5\xd1\x80 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb0 \xd0\xb2 \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xba\xd0\xb5 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xbe\xd0\xb2\n        num = int(token.replace(\'$argv\', \'\'))\n        arguments = storage.get_arguments()\n        if 0 <= num < len(arguments):\n            return arguments[num]\n        return Integer(0)\n\n    @classmethod\n    def validate_function(cls, token: str, storage: Storage):\n\n        # \xd0\xbf\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd1\x83 \xd1\x81 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb0\xd0\xbc\xd0\xb8\n        arguments_str: str = token[token.find(\'(\')+1:-1]\n        arguments_str = \'[\' + arguments_str + \']\'\n\n\n        # \xd0\xbf\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd1\x81 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb0\xd0\xbc\xd0\xb8\n        argument_list = cls.validate_list(arguments_str, storage).data \n\n        # \xd0\xb8\xd0\xbc\xd1\x8f \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n        function_name: str = token[:token.find(\'(\')]  \n\n        # \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd1\x8f \xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd1\x82\xd1\x81\xd1\x8f \xd0\xba\xd0\xb0\xd0\xba \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82, \xd0\xbf\xd0\xbe\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x8b\xd0\xb9 \xd0\xb2 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x83\xd1\x8e\n        var: Variable = cls.validate_variable(function_name, storage)\n\n        # \xd0\xb8\xd0\xb7\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xba\xd0\xb0\xd0\xb5\xd0\xbc \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd1\x8e function:\n        function: Object = var.obj\n\n        if function.type == \'function\':\n            if function.specification == \'userdefined\':\n\n                # \xd0\xbe\xd0\xb4\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd0\xbc \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba \xd0\xbf\xd0\xb0\xd1\x80\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x82\xd1\x80\xd0\xbe\xd0\xb2 \xd0\xb2 \xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xbb\xd0\xb8\xd1\x86\xd0\xb5 \xd0\xb0\xd1\x80\xd0\xb3\xd1\x83\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xbe\xd0\xb2\n                storage.add_arguments(argument_list) \n                obj: Object = function.run()\n\n            elif function.specification == \'builtin\':\n\n                # builtin \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8 \xd0\xbd\xd0\xb5 \xd0\xb8\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x8f\xd1\x8e\xd1\x82 \xd1\x81\xd1\x82\xd0\xb5\xd0\xba \xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xba\xd0\xbe\xd0\xb2 \xd0\xbf\xd0\xb0\xd1\x80\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x80\xd0\xbe\xd0\xb2\n                # \xd1\x82\xd0\xb0\xd0\xba \xd0\xba\xd0\xb0\xd0\xba \xd0\xb8\xd0\xb7 \xd0\xb2\xd1\x8b\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbd\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5 \xd0\xbd\xd0\xb5 \xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd1\x83\xd1\x81\xd0\xbc\xd1\x82\xd0\xb0\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb0\xd0\xb5\xd1\x82 \n                # \xd0\xb8\xd1\x81\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xb7\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80\xd0\xb0 return\n                obj: Object = function.run(argument_list, storage)\n\n        else:\n            obj: Object = Integer(0)\n\n        return obj\n\n    \n\n    @classmethod\n    def validate_operand(cls, token: str, tok_type: str, storage: Storage) -> Object:\n\n        if tok_type == \'variable\':\n            var: Variable = cls.validate_variable(token, storage)\n            return var\n\n        elif tok_type == \'function\':\n            obj: Object = cls.validate_function(token, storage)\n            return obj\n\n\n        elif tok_type == \'list\':\n            lst: List = cls.validate_list(token, storage)\n            return lst\n\n        elif tok_type == \'argument\':\n            obj: Object = cls.validate_argument(token, storage)\n            return obj\n        \n        else:\n            obj: Object = cls.validate_basic_object(token, tok_type) \n            return obj\n\n\n    def __repr__(self):\n        return f\'{self.stringg};\'\n\nif __name__ == \'__main__\':\n    text = \'[1+2] + ["aboba", []]\'\n    s = Storage({}, Stack())\n    e = Expression(text, s, True)\n    print(e.run())\n')
    __stickytape_write_module('list.py', b"from object import Object\n\n\nclass List(Object):\n    regex = '\\[.*\\]'\n    type: str = 'list'\n\n    def __init__(self, data: list[Object]):\n        self.data = data\n\n    def copy(self):\n        l = List(self.objects)\n        return l\n\n    def add(self, obj: Object):\n        self.data.append(obj)\n\n    def remove(self, index: int):\n        self.data.remove[index]\n\n    def len(self) -> int:\n        return len(self.data)\n\n    def get(self, index: int) -> Object:\n        return self.data[index]\n\n    def __repr__(self):\n        return str(self.data)\n\n")
    __stickytape_write_module('basic_types.py', b'from object import Object\nfrom void import Void\nfrom integer import Integer\nfrom stringg import String\nfrom float import Float\nfrom list import List\nfrom variable import Variable\n\nglobal BASIC_OBJECTS\nBASIC_OBJECTS: list[Object] = [Void, Integer, Float, String, List, Variable]\n\nglobal BASIC_TYPES\nBASIC_TYPES: dict[str: Object] = {obj.type: obj for obj in BASIC_OBJECTS}\n')
    __stickytape_write_module('float.py', b"from object import Object\n\n\nclass Float(Object):\n    regex = '-?\\d+\\.\\d+'\n    type: str = 'float'\n    def __init__(self, number):\n        self.data = float(number)\n\n    def __repr__(self):\n        return str(self.data)\n")
    __stickytape_write_module('operation.py', b"from object import Object\nfrom integer import Integer\nfrom variable import Variable\nfrom basic_types import BASIC_TYPES\nfrom storage import Storage\n\n\nclass Operation():                                                  # \xd0\x9a\xd0\xbb\xd0\xb0\xd1\x81\xd1\x81 \xd0\xb4\xd0\xbb\xd1\x8f \xd0\xbe\xd1\x81\xd1\x83\xd1\x89\xd0\xb5\xd1\x81\xd1\x82\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f \xd0\xb8 \xd0\xbc\xd0\xb5\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xb6\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb0\n    operations: dict[str, ()] = {\n            # \xd0\x9e\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8 \xd1\x81 \xd0\xbf\xd1\x80\xd0\xb8\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xb8\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5\xd0\xbc\n            #'+=': lambda lop, rop: lop + rop,\n            #'-=': lambda lop, rop: lop - rop,\n            #'*=': lambda lop, rop: lop * rop,\n            #'/=': lambda lop, rop: lop / rop,\n\n            # \xd0\x90\xd1\x80\xd0\xb8\xd1\x84\xd0\xbc\xd0\xb5\xd1\x82\xd0\xb8\xd1\x87\xd0\xb5\xd1\x81\xd0\xba\xd0\xb8\xd0\xb5 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\n            '+': lambda lop, rop: lop + rop,\n            '-': lambda lop, rop: lop - rop,\n            '*': lambda lop, rop: lop * rop,\n            '/': lambda lop, rop: lop / rop,\n\n            # \xd0\x9b\xd0\xbe\xd0\xb3\xd0\xb8\xd1\x87\xd0\xb5\xd1\x81\xd0\xba\xd0\xb8\xd0\xb5 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\n            '<': lambda lop, rop: lop < rop,\n            '>': lambda lop, rop: lop > rop,\n            '<=': lambda lop, rop: lop <= rop,\n            '>=': lambda lop, rop: lop >= rop,\n            '==': lambda lop, rop: lop == rop,\n            '!=': lambda lop, rop: lop != rop,\n            }\n\n\n    @classmethod\n    def __get_object(cls, operand: Object, storage: Storage) -> Object:\n        if operand.type == 'variable':                      # \xd0\x95\xd1\x81\xd0\xbb\xd0\xb8  \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb4 -- \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xb0\xd1\x8f\n            return storage.get(operand.name).obj            # \xd0\x98\xd0\xb7\xd0\xb2\xd0\xbb\xd0\xb5\xd1\x87\xd0\xb5\xd0\xbc \xd0\xb5\xd0\xb5 \xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\n        return operand\n\n    @classmethod\n    def __same_types(cls, lop: Object, rop: Object) -> bool:\n        # \xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x80\xd0\xbe\xd0\xb6\xd0\xbd\xd0\xbe, \xd0\xbe\xd0\xb4\xd0\xb8\xd0\xbd \xd0\xb8\xd0\xb7 \xd0\xbd\xd0\xb8\xd1\x85 \xd0\xbc\xd0\xbe\xd0\xb6\xd0\xb5\xd1\x82 \xd0\xb1\xd1\x8b\xd1\x82\xd1\x8c \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xbe\xd0\xb9\n        return lop.type == rop.type\n\n    @classmethod\n    def __valid_operation(cls, lop: Object, rop: Object, op: str, storage: Storage) -> bool:\n        lop = cls.__get_object(lop, storage)\n        rop = cls.__get_object(rop, storage)\n        if cls.__same_types(lop, rop):\n            if lop.type in ['list', 'stringg'] and op in ['-', '*', '/']:\n                return False\n            if rop.type in ['integer', 'float']:\n                if rop.data == 0 and op == '/':\n                    return False\n            return True\n        return False\n\n\n    # \xd0\x92 \xd0\xbf\xd1\x80\xd0\xb8\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xb8\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb8 \xd0\xbb\xd0\xb5\xd0\xb2\xd1\x8b\xd0\xb9 \xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb4 \xd0\xb2\xd1\x81\xd0\xb5\xd0\xb3\xd0\xb4\xd0\xb0 \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd0\xb0\xd1\x8f\n    @classmethod\n    def equate(cls, lop: Variable, rop: Object, storage: Storage) -> Object:\n        rop = cls.__get_object(rop, storage)\n        storage.set(lop.name, rop)\n        return rop\n\n    @classmethod\n    def operate(cls, lop: Object, rop: Object, op: str, storage: Storage) -> Object:\n        lop = cls.__get_object(lop, storage)\n        rop = cls.__get_object(rop, storage)\n        if cls.__valid_operation(lop, rop, op, storage):\n\n            if op in ['<', '>', '<=', '>=', '==', '!=']:\n                basic_type = Integer\n            elif op in ['+', '-', '*', '/']:\n                basic_type = BASIC_TYPES[lop.type]\n\n            func = cls.operations[op]\n            return basic_type(func(lop.data, rop.data))\n        return Integer(0)\n\n    @classmethod\n    def run(cls, lop: Object, rop: Object, op: str, storage: Storage):\n        if op == '=':\n            return cls.equate(lop, rop, storage)\n        else:\n            return cls.operate(lop, rop, op, storage)\n\n\n")
    __stickytape_write_module('construction_types.py', b'from expression_block import ExpressionBlock\nfrom block import Block\nfrom control_structures import *\nfrom main import Main\nfrom function_block import FunctionBlock\n\n\nglobal CONSTRUCTIONS_OBJECTS\nCONSTRUCTIONS_OBJECTS = [ExpressionBlock, Block, If, While, For, Main,\n                         FunctionBlock]\nglobal CONSTRUCTIONS_HEADS\nCONSTRUCTIONS_HEADS = {c.name: c for c in CONSTRUCTIONS_OBJECTS}\nglobal CONSTRUCTIONS_TYPES\nCONSTRUCTIONS_TYPES = {c.regex: c for c in CONSTRUCTIONS_OBJECTS}\n')
    __stickytape_write_module('control_structures.py', b"from object import Object\nfrom void import Void\nfrom integer import Integer\nfrom storage import Storage\nfrom construction import Construction\nfrom expression import Expression\nfrom block import Block\n\n\nclass If(Construction):\n    regex: str = 'If\\(.*?\\)'\n    name = 'If'\n    def __init__(self, header: str, block: Block, storage: Storage):\n        self.storage: Storage = storage\n        self.header = header\n        self.check_expression = self.get_check_expression()\n        self.block = block\n\n    def get_check_expression(self) -> Expression:\n        return Expression(self.clear(), self.storage, True)\n\n    def clear(self):\n        if self.header.startswith('If('):\n            return self.header[:-1].replace('If(', '')\n        return self.header\n\n    def run(self) -> Object:\n        result: Objcet = Void()\n        if self.check_expression.run().data:\n            result = self.block.run()\n        return result\n\n    def __repr__(self):\n        exp = str(self.check_expression)\n        block = str(self.block)\n        return f'{self.header}\\n{block}'\n\n\nclass While(Construction):\n    regex: str = 'While\\(.*?\\)'\n    name = 'While'\n    def __init__(self, header: str, block: Block, storage: Storage):\n        self.storage: Storage = storage\n        self.header = header\n        self.check_expression = self.get_check_expression()\n        self.block = block\n\n    def run(self) -> Object:\n        result: Object = Void()\n        while True:\n            flag = self.check_expression.run().data         # to get real int, not object\n            if flag:\n                result = self.block.run()\n            else:\n                break\n        return result\n        \n    def get_check_expression(self) -> Expression:\n        return Expression(self.clear(), self.storage, True)\n\n    def clear(self):\n        if self.header.startswith('While('):\n            return self.header[:-1].replace('While(', '')\n        return self.header\n\n    def __repr__(self):\n        block = str(self.block)\n        return f'{self.header}\\n{block}'\n\n\nclass For(Construction):\n    regex: str = 'For\\(.*?\\)'\n    name = 'For'\n    def __init__(self, header: str, block: Block, storage: Storage):\n        self.storage: Storage = storage\n        self.header = header\n        self.block = block\n        self.init_expressions()\n\n    def run(self) -> Object:\n        self.init_expression.run()\n        result: Object = Void()\n        while True:\n            flag = self.check_expression.run().data         # to get real int, not object\n            if flag:\n                result = self.block.run()\n                self.increment_expression.run()\n            else:\n                break\n        return result\n                \n    def init_expressions(self):\n        expressions = [s for s in self.clear().split(';') if s]\n        expressions = [Expression(e, self.storage, True) for e in expressions]\n        self.init_expression = expressions[0]\n        self.check_expression = expressions[1]\n        self.increment_expression = expressions[2]\n\n    def clear(self):\n        if self.header.startswith('For('):\n            return self.header[:-1].replace('For(', '')\n        return self.header\n\n    def __repr__(self):\n        block = str(self.block)\n        return f'{self.header}\\n{block}'\n\n")
    __stickytape_write_module('main.py', b"from block import Block\n\n\nclass Main(Block):\n    regex :str = 'Main'\n    name: str = 'Main'\n\n    def __repr__(self):\n        block = '\\n'.join(str(c) for c in self.constructions)\n        block =  f'{self.name}' +'{' + f'\\n{block}\\n' + '}'\n        return block\n")
    __stickytape_write_module('function_block.py', b"from re import search\nfrom construction import Construction\n\n\nclass FunctionBlock(Construction): # \xd0\xbd\xd0\xb5 \xd0\xbe\xd0\xb1\xd1\x8f\xd0\xb7\xd0\xb0\xd0\xbd\xd0\xb0 \xd0\xbd\xd0\xb0\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xb2\xd0\xb0\xd1\x82\xd1\x8c\xd1\x81\xd1\x8f \xd0\xbe\xd1\x82 \xd0\xba\xd0\xbe\xd0\xbd\xd1\x81\xd1\x82\xd1\x80\xd1\x83\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8. \xd0\xbc\xd0\xbe\xd0\xb6\xd0\xbd\xd0\xbe \xd0\xb2 \xd0\xbf\xd0\xb0\xd1\x80\xd1\x81\xd0\xb8\xd0\xbd\xd0\xb3\xd0\xb5 \xd0\xb4\xd0\xb5\xd1\x80\xd0\xb5\xd0\xb2\xd0\xb0 \xd0\xb4\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd1\x82\xd1\x8c \xd0\xb2 \xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xbb\xd0\xb8\xd1\x89\xd0\xb5\n    regex: str = 'Func\\(.*?\\)'\n    name: str = 'Func'\n\n    def __init__(self, text: str):\n        self.head = self.validate(text)\n\n    def validate(self, text: str):\n        m = search(self.regex, text)\n        head: str = text[m.start():m.end()-1].replace('Func(', '')\n        return head\n\n    def __repr__(self):\n        return 'fn#' + self.head\n\n")
    __stickytape_write_module('builder.py', b"from storage import Storage\nfrom construction import Construction\nfrom expression_block import ExpressionBlock\nfrom block import Block\nfrom function_block import FunctionBlock\nfrom construction_types import CONSTRUCTIONS_HEADS\nfrom callable import Function\nfrom variable import Variable\n\n\nclass Builder():\n    @classmethod\n    def __get_constructor(cls, header: str) -> object:\n        for head in CONSTRUCTIONS_HEADS.keys():\n            if header.startswith(head):\n                return CONSTRUCTIONS_HEADS[head]\n        return ExpressionBlock\n\n    @classmethod\n    def create_construction(cls, header: str, constructions: list[Construction], storage: Storage) -> Construction:\n\n        obj = cls.__get_constructor(header)\n\n        if obj.name == 'Expr':\n            return ExpressionBlock(header, storage)\n\n        if obj.name == 'Func':\n            func_block: FunctionBlock = FunctionBlock(header)\n\n            # \xd0\xb1\xd0\xbb\xd0\xbe\xd0\xba \xd0\xb4\xd0\xbb\xd1\x8f \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n            block = Block(constructions)\n            function: Function = Function(block)\n\n            func_name = func_block.head\n\n            # \xd1\x81\xd0\xbe\xd0\xb7\xd0\xb4\xd0\xb0\xd0\xb5\xd0\xbc \xd0\xbf\xd0\xb5\xd1\x80\xd0\xb5\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xbd\xd1\x83\xd1\x8e \xd1\x81 \xd0\xbe\xd0\xb1\xd1\x8a\xd0\xb5\xd0\xba\xd1\x82\xd0\xbe\xd0\xbc \xd1\x84\xd1\x83\xd0\xbd\xd0\xba\xd1\x86\xd0\xb8\xd0\xb8\n            var: Variable = Variable(func_block.head, function)\n\n            # \xd0\xb4\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd0\xbc \xd0\xb2 \xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xbb\xd0\xb8\xd1\x89\xd0\xb5\n            storage.add(var)\n            return Block([])\n\n        elif obj.name == 'Main' or obj.name == 'Block':\n            return obj(constructions)\n\n        else:\n            block = Block(constructions)\n            return obj(header, block, storage)\n")
    import re
    import sys
    from utils import syntax_analysis
    from stack import Stack
    from yer_builtins import BUILTINS
    from variable import Variable
    from storage import Storage
    from expression import Expression
    from construction_tree import ConstructionTree
    
    def main():
        print(
    ''' 
    Смотри документацию по ссылке: 
    https://github.com/MM-Collaboration-2/Project-Yer/tree/main
        ''')
    
        inp = ''
        buf = ''
        CURSOR_UP_ONE = '\x1b[1A'
        ERASE_LINE = '\x1b[2K' 
        variables = Storage(BUILTINS, Stack())
        while True:
            input_stringg = '>>> '
            inp = input(input_stringg)
            if inp == 'q':
                break
            if len(inp) == 0:
                continue
            else:
                if re.fullmatch('.*{.*', inp):
                    bracket_diff = inp.count('{') - inp.count('}')
                    buf = inp
                    input_stringg = '>>> ' + bracket_diff * '  '
                    while(bracket_diff > 0):
                        inp = input(input_stringg)               # inp - всегда текущая строка
                        bracket_diff += inp.count('{') - inp.count('}')
                        input_stringg = '>>> ' + bracket_diff * '  '
                        if re.fullmatch('}.*', inp):
                            print(CURSOR_UP_ONE+ERASE_LINE+input_stringg+inp)
                        buf += inp
                    t = ConstructionTree(syntax_analysis(buf, logging=True), variables)
                    outp = t.run()
                else:
                    exp = Expression(inp, variables, True)
                    outp = exp.run()
            if outp.type != 'void':
                print(outp)
    
    
    if sys.argv[1:]: # файл указан
        with open(sys.argv[1], "r") as f:
            variables = Storage(BUILTINS, Stack())
            text = f.read()
            text = syntax_analysis(text)
            t = ConstructionTree(syntax_analysis(text, logging=True), variables)
            t.run()
    else:
        main()
    